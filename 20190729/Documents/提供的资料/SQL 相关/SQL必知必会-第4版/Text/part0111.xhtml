<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <link href="../Styles/style0002.css" rel="stylesheet" type="text/css"/>
<link href="../Styles/style0001.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="calibre15" id="nav_point_166">22.1  约束</h2><p class="calibre2">SQL已经改进过多个版本，成为非常完善和强大的语言。许多强有力的特性给用户提供了高级的数据处理技术，如约束。</p>

<p class="calibre2">关联表和引用完整性已经在前面讨论过几次。正如所述，关系数据库存储分解为多个表的数据，每个表存储相应的数据。利用键来建立从一个表到另一个表的引用（由此产生了术语<strong class="calibre3">引用完整性</strong>（referential integrity））。  </p>

<p class="calibre2">正确地进行关系数据库设计，需要一种方法保证只在表中插入合法数据。例如，如果<code class="calibre11">Orders</code>表存储订单信息，<code class="calibre11">OrderItems</code>表存储订单详细内容，应该保证<code class="calibre11">OrderItems</code>中引用的任何订单ID都存在于<code class="calibre11">Orders</code>中。类似地，在<code class="calibre11">Orders</code>表中引用的任意顾客必须存在于<code class="calibre11">Customers</code>表中。</p>

<p class="calibre2">虽然可以在插入新行时进行检查（在另一个表上执行<code class="calibre11">SELECT</code>，以保证所有值合法并存在），但最好不要这样做，原因如下：</p>

<ul class="calibre8">
<li class="calibre9">如果在客户端层面上实施数据库完整性规则，则每个客户端都要被迫实施这些规则，一定会有一些客户端不实施这些规则。</li>
<li class="calibre9">在执行<code class="calibre11">UPDATE</code>和<code class="calibre11">DELETE</code>操作时，也必须实施这些规则。</li>
<li class="calibre9">执行客户端检查是非常耗时的，而DBMS执行这些检查会相对高效。</li>
</ul>

<blockquote class="calibre13">
  <p class="calibre2"><strong class="calibre3">约束（constraint）</strong><br class="calibre14"/>
  管理如何插入或处理数据库数据的规则。</p>
</blockquote>

<p class="calibre2">DBMS通过在数据库表上施加约束来实施引用完整性。大多数约束是在表定义中定义的，如第17课所述，用<code class="calibre11">CREATE TABLE</code>或<code class="calibre11">ALTER TABLE</code>语句。</p>

<blockquote class="calibre13">
  <p class="calibre2"><strong class="calibre3">注意：具体DBMS的约束</strong><br class="calibre14"/>
  有几种不同类型的约束，每个DBMS都提供自己的支持。因此，这里给出的例子在不同的DBMS上可能有不同的反应。在进行试验之前，请参阅具体的DBMS文档。</p>
</blockquote>
<h3 class="calibre7" id="nav_point_167">22.1.1  主键</h3><p class="calibre2">我们在第1课简单提过主键。主键是一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动。换句话说，表中的一列（或多个列）的值唯一标识表中的每一行。这方便了直接或交互地处理表中的行。没有主键，要安全地<code class="calibre11">UPDATE</code>或<code class="calibre11">DELETE</code>特定行而不影响其他行会非常困难。</p>

<p class="calibre2">表中任意列只要满足以下条件，都可以用于主键：</p>

<ul class="calibre8">
<li class="calibre9">任意两行的主键值都不相同。</li>
<li class="calibre9">每行都具有一个主键值（即列中不允许<code class="calibre11">NULL</code>值）。</li>
<li class="calibre9">包含主键值的列从不修改或更新。（大多数DBMS不允许这么做，但如果你使用的DBMS允许这样做，好吧，千万别！）</li>
<li class="calibre9">主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。</li>
</ul>

<p class="calibre2">一种定义主键的方法是创建它，如下所示：</p>

<p class="calibre2"><strong class="calibre3">输入▼</strong> </p>

<pre class="calibre10"><code class="calibre11">CREATE TABLE Vendors 
(
vend_id         CHAR(10)       NOT NULL PRIMARY KEY, 
vend_name       CHAR(50)       NOT NULL,
vend_address    CHAR(50)       NULL,
vend_city       CHAR(50)       NULL,
vend_state      CHAR(5)        NULL,
vend_zip        CHAR(10)       NULL,
vend_country    CHAR(50)       NULL
);
</code></pre>

<p class="calibre2"><strong class="calibre3">分析▼</strong><br class="calibre14"/>
在此例子中，给表的<code class="calibre11">vend_id</code>列定义添加关键字<code class="calibre11">PRIMARY KEY</code>，使其成为主键。</p>

<p class="calibre2"><strong class="calibre3">输入▼</strong> </p>

<pre class="calibre10"><code class="calibre11">ALTER TABLE Vendors 
ADD CONSTRAINT PRIMARY KEY (vend_id);
</code></pre>

<p class="calibre2"><strong class="calibre3">分析▼</strong><br class="calibre14"/>
这里定义相同的列为主键，但使用的是<code class="calibre11">CONSTRAINT</code>语法。此语法也可以用于<code class="calibre11">CREATE TABLE</code>和<code class="calibre11">ALTER TABLE</code>语句。 </p>

<blockquote class="calibre13">
  <p class="calibre2"><strong class="calibre3">说明：SQLite中的键</strong><br class="calibre14"/>
  SQLite不允许使用<code class="calibre11">ALTER TABLE</code>定义键，要求在初始的<code class="calibre11">CREATE TABLE</code>语句中定义它们。</p>
</blockquote>
<h3 class="calibre7" id="nav_point_168">22.1.2  外键</h3><p class="calibre2">外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完整性的极其重要部分。我们举个例子来理解外键。</p>

<p class="calibre2"><code class="calibre11">Orders</code>表将录入到系统的每个订单作为一行包含其中。顾客信息存储在<code class="calibre11">Customers</code>表中。<code class="calibre11">Orders</code>表中的订单通过顾客ID与<code class="calibre11">Customers</code>表中的特定行相关联。顾客ID为<code class="calibre11">Customers</code>表的主键，每个顾客都有唯一的ID。订单号为<code class="calibre11">Orders</code>表的主键，每个订单都有唯一的订单号。</p>

<p class="calibre2"><code class="calibre11">Orders</code>表中顾客ID列的值不一定是唯一的。如果某个顾客有多个订单，则有多个行具有相同的顾客ID（虽然每个订单都有不同的订单号）。同时，<code class="calibre11">Orders</code>表中顾客ID列的合法值为<code class="calibre11">Customers</code>表中顾客的ID。</p>

<p class="calibre2">这就是外键的作用。在这个例子中，在<code class="calibre11">Orders</code>的顾客ID列上定义了一个外键，因此该列只能接受<code class="calibre11">Customers</code>表的主键值。</p>

<p class="calibre2">下面是定义这个外键的方法：</p>

<p class="calibre2"><strong class="calibre3">输入▼</strong></p>

<pre class="calibre10"><code class="calibre11">CREATE TABLE Orders
(
    order_num     INTEGER     NOT NULL PRIMARY KEY,
    order_date    DATETIME    NOT NULL,
    cust_id       CHAR(10)    NOT NULL REFERENCES Customers(cust_id)
);
</code></pre>

<p class="calibre2"><strong class="calibre3">分析▼</strong><br class="calibre14"/>
其中的表定义使用了<code class="calibre11">REFERENCES</code>关键字，它表示<code class="calibre11">cust_id</code>中的任何值都必须是<code class="calibre11">Customers</code>表的<code class="calibre11">cust_id</code>中的值。</p>

<p class="calibre2">相同的工作也可以在<code class="calibre11">ALTER TABLE</code>语句中用<code class="calibre11">CONSTRAINT</code>语法来完成：</p>

<p class="calibre2"><strong class="calibre3">输入▼</strong></p>

<pre class="calibre10"><code class="calibre11">ALTER TABLE Orders
ADD CONSTRAINT
FOREIGN KEY (cust_id) REFERENCES Customers (cust_id)
</code></pre>

<blockquote class="calibre13">
  <p class="calibre2"><strong class="calibre3">提示：外键有助防止意外删除</strong><br class="calibre14"/>
  如第6课所述，除帮助保证引用完整性外，外键还有另一个重要作用。在定义外键后，DBMS不允许删除在另一个表中具有关联行的行。例如，不能删除关联订单的顾客。删除该顾客的唯一方法是首先删除相关的订单（这表示还要删除相关的订单项）。由于需要一系列的删除，因而利用外键可以防止意外删除数据。</p>
  
  <p class="calibre2">有的DBMS支持称为级联删除（cascading delete）的特性。如果启用，该特性在从一个表中删除行时删除所有相关的数据。例如，如果启用级联删除并且从<code class="calibre11">Customers</code>表中删除某个顾客，则任何关联的订单行也会被自动删除。</p>
</blockquote>
<h3 class="calibre7" id="nav_point_169">22.1.3  唯一约束</h3><p class="calibre2">唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别。</p>

<ul class="calibre8">
<li class="calibre9">表可包含多个唯一约束，但每个表只允许一个主键。</li>
<li class="calibre9">唯一约束列可包含<code class="calibre11">NULL</code>值。</li>
<li class="calibre9">唯一约束列可修改或更新。</li>
<li class="calibre9">唯一约束列的值可重复使用。</li>
<li class="calibre9">与主键不一样，唯一约束不能用来定义外键。</li>
</ul>

<p class="calibre2"><code class="calibre11">employees</code>表是一个使用约束的例子。每个雇员都有唯一的社会安全号，但我们并不想用它作主键，因为它太长（而且我们也不想使该信息容易利用）。因此，每个雇员除了其社会安全号外还有唯一的雇员ID（主键）。</p>

<p class="calibre2">雇员ID是主键，可以确定它是唯一的。你可能还想使DBMS保证每个社会安全号也是唯一的（保证输入错误不会导致使用他人号码）。可以通过在社会安全号列上定义<code class="calibre11">UNIQUE</code>约束做到。</p>

<p class="calibre2">唯一约束的语法类似于其他约束的语法。唯一约束既可以用<code class="calibre11">UNIQUE</code>关键字在表定义中定义，也可以用单独的<code class="calibre11">CONSTRAINT</code>定义。</p>
<h3 class="calibre7" id="nav_point_170">22.1.4  检查约束</h3><p class="calibre2">检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。检查约束的常见用途有以下几点。</p>

<ul class="calibre8">
<li class="calibre9">检查最小或最大值。例如，防止0个物品的订单（即使0是合法的数）。</li>
<li class="calibre9">指定范围。例如，保证发货日期大于等于今天的日期，但不超过今天起一年后的日期。</li>
<li class="calibre9">只允许特定的值。例如，在性别字段中只允许<code class="calibre11">M</code>或<code class="calibre11">F</code>。</li>
</ul>

<p class="calibre2">换句话说，第1课介绍的数据类型限制了列中可保存的数据的类型。检查约束在数据类型内又做了进一步的限制，这些限制极其重要，可以确保插入数据库的数据正是你想要的数据。不需要依赖于客户端应用程序或用户来保证正确获取它，DBMS本身将会拒绝任何无效的数据。</p>

<p class="calibre2">下面的例子对<code class="calibre11">OrderItems</code>表施加了检查约束，它保证所有物品的数量大于0：</p>

<p class="calibre2"><strong class="calibre3">输入▼</strong></p>

<pre class="calibre10"><code class="calibre11">CREATE TABLE OrderItems
(
    order_num     INTEGER     NOT NULL,
    order_item    INTEGER     NOT NULL,
    prod_id       CHAR(10)    NOT NULL,
    quantity      INTEGER     NOT NULL CHECK (quantity &gt; 0),
    item_price    MONEY       NOT NULL
);
</code></pre>

<p class="calibre2"><strong class="calibre3">分析▼</strong><br class="calibre14"/>
利用这个约束，任何插入（或更新）的行都会被检查，保证<code class="calibre11">quantity</code>大于0。</p>

<p class="calibre2">检查名为<code class="calibre11">gender</code>的列只包含<code class="calibre11">M</code>或<code class="calibre11">F</code>，可编写如下的<code class="calibre11">ALTER TABLE</code>语句：</p>

<p class="calibre2"><strong class="calibre3">输入▼</strong></p>

<pre class="calibre10"><code class="calibre11">ADD CONSTRAINT CHECK (gender LIKE '[MF]')
</code></pre>

<blockquote class="calibre13">
  <p class="calibre2"><strong class="calibre3">提示：用户定义数据类型</strong><br class="calibre14"/>
  有的DBMS允许用户定义自己的数据类型。它们是定义检查约束（或其他约束）的基本简单数据类型。例如，你可以定义自己的名为<code class="calibre11">gender</code>的数据类型，它是单字符的文本数据类型，带限制其值为<code class="calibre11">M</code>或<code class="calibre11">F</code>（对于未知值或许还允许<code class="calibre11">NULL</code>）的检查约束。然后，可以将此数据类型用于表的定义。定制数据类型的优点是只需施加约束一次（在数据类型定义中），而每当使用该数据类型时，都会自动应用这些约束。请查阅相应的DBMS文档，看它是否支持自定义数据类型。</p>
</blockquote>
</body>
</html>
